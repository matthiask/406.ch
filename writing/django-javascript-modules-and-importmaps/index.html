<!doctypehtml><html lang=en><meta charset=utf-8><meta content=width=device-width,initial-scale=1.0 name=viewport><title>Django, JavaScript modules and importmaps - Matthias Kestenholz</title><link href=/styles.7a4c5338b9f2.css rel=stylesheet><link title="Blog feed"href=/writing/atom.xml rel=alternate type=application/atom+xml><body><header><div class=wrappy><a class=title href=/>Hi, I'm Matthias</a><p class=subtitle>I am a founding partner of <a href=https://feinheit.ch>Feinheit AG</a> and <a href=https://diebruchpiloten.com>Die Bruchpiloten AG</a>. Find me on <a href=https://github.com/matthiask/>GitHub</a>, <a href=https://hachyderm.io/@matthiask rel=me>Mastodon</a>, <a href=https://bsky.app/profile/matthiask.406.ch rel=me>Bluesky</a>, <a rel="noopener noreferrer"title="if you must"href=https://www.linkedin.com/in/matthiaskestenholz target=_blank>LinkedIn</a> or by <a href=mailto:mk@406.ch>email</a>.<nav><a href=/writing/category-climate/>Climate</a><a href=/writing/category-django/>Django</a><a href=/writing/category-feincms/>feincms</a><a href=/writing/category-feincms3/>feincms3</a><a href=/writing/category-politik/>Politik</a><a href=/writing/category-programming/>Programming</a><a href=/writing/category-python/>Python</a><a href=/writing/category-til/>TIL</a><a href=/writing/category-weeknotes/>Weeknotes</a></nav></div></header><main><div class=wrappy><div class=text><small>2025-05-22 </small><h1 id=how-im-using-django-javascript-modules-and-importmaps-together><a class=toclink href=#how-im-using-django-javascript-modules-and-importmaps-together>How I’m using Django, JavaScript modules and importmaps together</a></h1><p>I have been spending a lot of time in the last few months working on <a href=https://github.com/matthiask/django-prose-editor/>django-prose-editor</a>. First I’ve rebuilt the editor on top of <a href=https://406.ch/writing/rebuilding-django-prose-editor-from-the-ground-up/>Tiptap</a> because I wanted a framework for extending the underlying <a href=https://prosemirror.net/>ProseMirror</a> and didn’t want to reinvent this particular wheel. While doing that work I noticed that using JavaScript modules in the browser would be really nice, but Django’s <code>ManifestStaticFilesStorage</code> doesn’t yet support rewriting <code>import</code> statement in modules out-of-the-box without opting into the experimental support accessible through subclassing the storage. A better way to use JavaScript modules with the cache busting offered by <code>ManifestStaticFilesStorage</code> would be <a href=https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap>importmaps</a>.<h2 id=motivation><a class=toclink href=#motivation>Motivation</a></h2><p>Developing Django applications that include JavaScript has always been challenging when it comes to properly distributing, loading, and versioning those assets. The traditional approach using Django’s <code>forms.Media</code> works well for simple use cases, but falls short when dealing with modern JavaScript modules.<p>The ability to ship reusable JavaScript utilities in third-party Django apps has been a pain point for years. Often developers resort to workarounds like bundling all JS into a single file, using jQuery-style global variables, or requiring complex build processes for consumers of their apps.<p>Importmaps offer a cleaner solution that works with native browser modules, supports cache busting, and doesn’t require complex bundling for simple use cases.<h2 id=the-history><a class=toclink href=#the-history>The history</a></h2><p>The conversation around better JavaScript handling in Django has been ongoing for years. Thibaud Colas’ <a href=https://github.com/django/deps/pull/84>DEP draft</a> come to mind as does the <a href=https://forum.djangoproject.com/t/rejuvenating-vs-deprecating-form-media/21285>discussion about whether to improve or deprecate <code>forms.Media</code></a>.<p>A few packages exist which are offering solutions in this space:<ul><li><a href=https://github.com/codingjoe/django-esm>django-esm</a> provides a solution for using ES modules with Django without bundling.<li><a href=https://github.com/matthiask/django-js-asset/>django-js-asset</a> provides helpers for delivering JavaScript modules, importmaps, JSON blobs etc. to the browser through Django’s <code>forms.Media</code>. The blog post <a href=https://406.ch/writing/object-based-assets-for-django-s-forms-media/>Object-based assets for Django’s forms.Media</a> explores this in more detail.<li>The article on <a href=https://406.ch/writing/django-admin-apps-and-content-security-policy-compliance/>Content Security Policy compliance</a> explores better approaches to use JavaScript in the Django admin while avoiding inline JavaScript.</ul><p>django-js-asset came before Django <a href=https://github.com/django/django/commit/4c76ffc2d6c77>added official support for object-based media CSS and JS paths</a> but has since been changed to take advantage of that official support. It has enabled the removal of ugly hacks. In the meantime, Django has even added <a href=https://github.com/django/django/pull/18782>official support for object-based <code>Script</code> tags</a>.<h2 id=my-dep-draft><a class=toclink href=#my-dep-draft>My DEP draft</a></h2><p>Building on these efforts, I’ve been thinking about <a href=https://github.com/django/deps/pull/101>submitting my own DEP draft for importmap support</a>. It hasn’t yet come far though, and I’m still more occupied with verifying and using my existing solution, especially learning if it has limitations which would make the implemented approach unworkable for official inclusion.<h2 id=the-current-effort><a class=toclink href=#the-current-effort>The current effort</a></h2><p>As alluded to above, I already have a working solution for using importmaps (in django-js-asset) and I’m actively using it in django-prose-editor. Here’s how it works:<div class=chl><pre><span></span><code><span class=n>importmap</span><span class=o>.</span><span class=n>update</span><span class=p>({</span>
    <span class=s2>"imports"</span><span class=p>:</span> <span class=p>{</span>
        <span class=s2>"django-prose-editor/editor"</span><span class=p>:</span> <span class=n>static_lazy</span><span class=p>(</span><span class=s2>"django_prose_editor/editor.js"</span><span class=p>),</span>
    <span class=p>}</span>
<span class=p>})</span>
</code></pre></div><p>A minimal editor implementation using this:<div class=chl><pre><span></span><code><span class=k>import</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=c1>// Tiptap extensions</span>
<span class=w>  </span><span class=nx>Document</span><span class=p>,</span><span class=w> </span><span class=nx>Paragraph</span><span class=p>,</span><span class=w> </span><span class=nx>HardBreak</span><span class=p>,</span><span class=w> </span><span class=nx>Text</span><span class=p>,</span><span class=w> </span><span class=nx>Bold</span><span class=p>,</span><span class=w> </span><span class=nx>Italic</span><span class=p>,</span>

<span class=w>  </span><span class=c1>// Prose editor utilities</span>
<span class=w>  </span><span class=nx>Menu</span><span class=p>,</span><span class=w> </span><span class=nx>createTextareaEditor</span><span class=p>,</span><span class=w> </span><span class=nx>initializeEditors</span><span class=p>,</span>
<span class=p>}</span><span class=w> </span><span class=kr>from</span><span class=w> </span><span class=s2>"django-prose-editor/editor"</span>

<span class=kd>const</span><span class=w> </span><span class=nx>extensions</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span>
<span class=w>  </span><span class=nx>Document</span><span class=p>,</span><span class=w> </span><span class=nx>Paragraph</span><span class=p>,</span><span class=w> </span><span class=nx>HardBreak</span><span class=p>,</span><span class=w> </span><span class=nx>Text</span><span class=p>,</span><span class=w> </span><span class=nx>Bold</span><span class=p>,</span><span class=w> </span><span class=nx>Italic</span><span class=p>,</span><span class=w> </span><span class=nx>Menu</span><span class=p>,</span>
<span class=p>]</span>

<span class=nx>initializeEditors</span><span class=p>((</span><span class=nx>textarea</span><span class=p>)</span><span class=w> </span><span class=p>=></span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=nx>createTextareaEditor</span><span class=p>(</span><span class=nx>textarea</span><span class=p>,</span><span class=w> </span><span class=nx>extensions</span><span class=p>)</span>
<span class=p>})</span>
</code></pre></div><p>The importmap looks as follows when using Django’s <code>ManifestStaticFilesStorage</code> which produces filenames containing the hash of the file’s contents for cache busting (edited for readability):<div class=chl><pre><span></span><code><span class=p><</span><span class=nt>script</span> <span class=na>type</span><span class=o>=</span><span class=s>"importmap"</span><span class=p>></span>
<span class=p>{</span><span class=s2>"imports"</span><span class=o>:</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=s2>"django-prose-editor/editor"</span><span class=o>:</span><span class=w> </span><span class=s2>"/static/django_prose_editor/editor.6e8dd4c12e2e.js"</span>
<span class=p>}}</span>
<span class=p>&LT/</span><span class=nt>script</span><span class=p>></span>
</code></pre></div><p>This means that when your code has <code>import { ... } from "django-prose-editor/editor"</code>, the browser automatically loads the file from <code>/static/django_prose_editor/editor.6e8dd4c12e2e.js</code>. The hashed filename provides cache busting while the import statement remains clean and consistent.<h2 id=problems-with-the-current-implementation><a class=toclink href=#problems-with-the-current-implementation>Problems with the current implementation</a></h2><p>While this approach works, there are several issues to address:<ul><li><p>I don’t really like global variables but there doesn’t seem to be a way around it. Browsers want to use a single importmap only (even though the algorithm for merging importmaps exists in the spec!) and the importmap has to be included above all ES modules.</p><li><p>The fact that browsers only want a single importmap also means that when you use django-js-asset’s importmap support you <strong>cannot</strong> use a different package offering its own solution for importmaps.</p><li><p>The importmap may be added twice to the HTML when using a widget that works in both the admin and frontend contexts. Currently, if you want to avoid this problem or ugliness you have to determine in your Django form field if the code is requesting an admin widget or another widget, either by inspecting the callstack (very ugly) or by checking if the <code>widget</code> argument to the form field constructor is set to an admin-specific widget (also somewhat ugly, since widgets can be classes, instances, or not provided at all).</p><li><p>It would be nice if we the installation of django-prose-editor didn’t have more steps than what we have when installing any other Django widget integration. I’d like a more elegant solution, but haven’t found one yet that doesn’t introduce too much magic.</p></ul><h2 id=comparison-to-django-esm><a class=toclink href=#comparison-to-django-esm>Comparison to django-esm</a></h2><p><a href=https://github.com/codingjoe/django-esm>django-esm</a> takes a different approach. It assumes you’re using JavaScript modules everywhere and solves the problem of exposing the correct paths to those modules to the browser. It supports both private modules from your repository and modules installed in <code>node_modules</code>.<p>However, it doesn’t fully address the scenario where a third-party <strong>Django</strong> app (a Python package) ships JavaScript modules that need to be integrated into your application.<p>I still use a bundler for most of my JavaScript from <code>node_modules</code>, so I don’t need this specific functionality yet. That will probably change in the future.<h2 id=using-bundlers><a class=toclink href=#using-bundlers>Using bundlers</a></h2><p>If you’re still using a bundler, <a href=https://rspack.dev/>as I do</a>, you want to ensure that the <code>import</code> isn’t actually evaluated by the bundler but left as-is. The <a href=https://rspack.dev/>rspack</a> configuration I’m using at the moment is also documented in the django-prose-editor README but I’m duplicating it here for convenience:<div class=chl><pre><span></span><code><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=c1>// ...</span>
<span class=w>  </span><span class=nx>experiments</span><span class=o>:</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>outputModule</span><span class=o>:</span><span class=w> </span><span class=kc>true</span><span class=w> </span><span class=p>},</span>
<span class=w>  </span><span class=nx>externals</span><span class=o>:</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=s2>"django-prose-editor/editor"</span><span class=o>:</span><span class=w> </span><span class=s2>"module django-prose-editor/editor"</span><span class=p>,</span>
<span class=w>    </span><span class=c1>// Or the following, I'm never sure.</span>
<span class=w>    </span><span class=s2>"django-prose-editor/editor"</span><span class=o>:</span><span class=w> </span><span class=s2>"import django-prose-editor/editor"</span><span class=p>,</span>
<span class=w>  </span><span class=p>},</span>
<span class=p>}</span>
</code></pre></div><p>This configuration marks the dependency as “external” (so it won’t be bundled) and specifies that it should be loaded as a module using a static <code>import</code> statement.<p>For browser compatibility, you can also include <a href=https://github.com/guybedford/es-module-shims>es-module-shims</a> to support browsers that don’t yet handle importmaps natively (around 5% at the time of writing according to <a href=https://caniuse.com/import-maps>caniuse.com</a>).<h2 id=using-django-compressor-or-similar-packages><a class=toclink href=#using-django-compressor-or-similar-packages>Using django-compressor or similar packages</a></h2><p>Tools like django-compressor aren’t well-suited for modern JavaScript modules as they typically produce old-style JavaScript files rather than ES modules. They’re designed for a different era of web development and don’t integrate well with the importmap approach.<div class="admonition note"><p class=admonition-title>Note<p>The problem is that django-compressor at this time emits non-module script files. Using import statements in these files isn’t possible, instead you have to use <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import>dynamic imports</a>.<div class=chl><pre><span></span><code><span class=c1>// Instead of</span>
<span class=k>import</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>Document</span><span class=p>,</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=kr>from</span><span class=w> </span><span class=s2>"django-prose-editor/editor"</span>
<span class=c1>// you need</span>
<span class=k>import</span><span class=p>(</span><span class=s2>"django-prose-editor/editor"</span><span class=p>).</span><span class=nx>then</span><span class=p>(({</span><span class=w> </span><span class=nx>Document</span><span class=p>,</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>})</span><span class=w> </span><span class=p>=></span><span class=w> </span><span class=p>{</span>
<span class=p>})</span>
</code></pre></div><p>Both work fine. The bundle emitted by django-compressor will not contain the prose editor module itself though; including this module inside the bundle is not possible.</div><h2 id=conclusion><a class=toclink href=#conclusion>Conclusion</a></h2><p>Using importmaps with Django provides a clean solution for managing JavaScript modules in Django applications, especially for third-party apps that need to ship their own JavaScript. While there are still some rough edges to smooth out, this approach works well and offers a path forward that aligns with modern web standards.<p>Have you tried using importmaps with Django? I’d be interested to hear about your experiences and approaches.</div><div class="text prevnext"><span> </span><a href=/writing/weeknotes-2025-week-21/>Next post</a></div></div></main><footer><div class=wrappy><p><small> I like feedback! <a href="mailto:mk@406.ch?subject=Django, JavaScript modules and importmaps">Send me an email.</a> <br> <a rel="noopener noreferrer"href=https://ko-fi.com/matthiask target=_blank>☕ Buy me a coffee?</a> <br> Published on 2025-05-22 in <a href=/writing/category-django/>Django</a>, <a href=/writing/category-programming/>Programming</a> </small></p><script async crossorigin issue-term=pathname repo=matthiask/406-comments src=https://utteranc.es/client.js theme=github-dark></script></div></footer>