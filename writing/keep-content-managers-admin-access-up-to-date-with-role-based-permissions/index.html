<!doctypehtml><html lang=en><meta charset=utf-8><meta content=width=device-width,initial-scale=1.0 name=viewport><title>Keep content managers' admin access up-to-date with role-based permissions - Matthias Kestenholz</title><link href=/styles.50086b436dc6.css rel=stylesheet><link title="Blog feed"href=/writing/atom.xml rel=alternate type=application/atom+xml><body><header><div class=wrappy><a class=title href=/>Hi, I'm Matthias</a><p class=subtitle>I am a founding partner of <a href=https://feinheit.ch>Feinheit AG</a> and <a href=https://diebruchpiloten.com>Die Bruchpiloten AG</a>. Find me on <a href=https://github.com/matthiask/>GitHub</a>, <a href=https://hachyderm.io/@matthiask rel=me>Mastodon</a>, <a rel="noopener noreferrer"title="if you must"href=https://www.linkedin.com/in/matthiaskestenholz target=_blank>LinkedIn</a> or by <a href=mailto:mk@406.ch>email</a>.<nav><a href=/writing/category-climate/>Climate</a><a href=/writing/category-django/>Django</a><a href=/writing/category-feincms/>feincms</a><a href=/writing/category-feincms3/>feincms3</a><a href=/writing/category-politik/>Politik</a><a href=/writing/category-programming/>Programming</a><a href=/writing/category-python/>Python</a><a href=/writing/category-weeknotes/>Weeknotes</a></nav></div></header><main><div class=wrappy><div class=text><small>2023-09-20 </small><h1 id=keep-content-managers-django-admin-access-up-to-date-with-role-based-permissions><a class=toclink href=#keep-content-managers-django-admin-access-up-to-date-with-role-based-permissions>Keep content managers’ Django admin access up-to-date with role-based permissions</a></h1><p><a href=https://docs.djangoproject.com/en/4.2/topics/auth/default/#permissions-and-authorization>Django’s built-in permissions system</a> is great if you want fine-grained control of the permissions content managers should have. The allowlist-based approach where users have no permissions by default and must be granted each permission individually makes a lot of sense to me and is easy to understand.<p>When we build a CMS at <a href=https://feinheit.ch/>Feinheit</a> we often use the Django administration panel as a CMS. Unfortunately, Django doesn’t provide a way to specify that content managers should have all permissions in the <code>pages</code> and <code>articles</code> app (just as an example). Adding all current permissions in a particular app is straightforward when using the <a href=https://docs.djangoproject.com/en/4.2/ref/contrib/admin/#django.contrib.admin.ModelAdmin.filter_horizontal><code>filter_horizontal</code></a> interface but keeping the list up-to-date later isn’t. When we add an additional <a href=https://406.ch/writing/my-reaction-to-the-block-driven-cms-blog-post/>content block plugin</a> we always have to remember to also update the permissions after deploying the change – and often, deployment happens some time after the code has been written, e.g. because clients want to approve the change first. What happens all too often is that the manual step of updating permissions gets forgotten.<p>This has annoyed me (intermittently) for a long time and my preferred solution has always been to give superuser permissions to everyone and trust them to not make changes which they aren’t supposed to according to the <em>Trusted Users Editing Structured Content</em> principle which was mentioned in a Django book I read early in my Django journey.<h2 id=the-basic-ideas-of-my-role-based-permissions-implementation><a class=toclink href=#the-basic-ideas-of-my-role-based-permissions-implementation>The basic ideas of my role-based permissions implementation</a></h2><p>A recent project has resurfaced this annoyance and I did finally bite the bullet and implement a solution for this in the form of a <a href=https://github.com/matthiask/django-authlib/>django-authlib</a> extension. The basic ideas are:<p><strong>All users are assigned a single role</strong>: Single roles sound inflexible, but is good enough for my default use case. Examples for roles could be <em>default</em> (no additional permissions granted), <em>content managers</em> (grant access to the pages and articles apps) or maybe <em>deny auth</em> (deny access to users, groups and permissions).<p><strong>The permission check is implemented using a single callable</strong>: A custom backend is provided whose only job is to call the correct callable for the user’s current role.<p><strong>The callable either returns a boolean or raises <code>PermissionDenied</code> to prevent other backends from granting access</strong>: No new ideas here, it’s exactly what <a href=https://docs.djangoproject.com/en/4.2/topics/auth/customizing/#handling-authorization-in-custom-backends>Django’s authentication backends are supposed to do</a>.<p><strong>Permission checkers for the most common scenarios are bundled</strong>: django-authlib only ships one permission checker right now, <code>allow_deny_globs</code>, which allows specifying a list of permission name globs to allow and to deny. Deny overrides allow as is probably expected.<h2 id=using-roles-in-your-own-project><a class=toclink href=#using-roles-in-your-own-project>Using roles in your own project</a></h2><p>Specify the available roles in your settings and add the authentication backend:<div class=chl><pre><span></span><code><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>partial</span>
<span class=kn>from</span> <span class=nn>authlib.roles</span> <span class=kn>import</span> <span class=n>allow_deny_globs</span>
<span class=kn>from</span> <span class=nn>django.utils.translation</span> <span class=kn>import</span> <span class=n>gettext_lazy</span> <span class=k>as</span> <span class=n>_</span>

<span class=n>AUTHLIB_ROLES</span> <span class=o>=</span> <span class=p>{</span>
    <span class=s2>"default"</span><span class=p>:</span> <span class=p>{</span><span class=s2>"title"</span><span class=p>:</span> <span class=n>_</span><span class=p>(</span><span class=s2>"default"</span><span class=p>)},</span>
    <span class=s2>"staff"</span><span class=p>:</span> <span class=p>{</span>
        <span class=s2>"title"</span><span class=p>:</span> <span class=n>_</span><span class=p>(</span><span class=s2>"editorial staff"</span><span class=p>),</span>
        <span class=s2>"callback"</span><span class=p>:</span> <span class=n>partial</span><span class=p>(</span>
            <span class=n>allow_deny_globs</span><span class=p>,</span>
            <span class=n>allow</span><span class=o>=</span><span class=p>{</span>
                <span class=s2>"pages.*"</span><span class=p>,</span>
                <span class=s2>"articles.*"</span><span class=p>,</span>
            <span class=p>},</span>
        <span class=p>),</span>
    <span class=p>},</span>
<span class=p>}</span>

<span class=n>AUTHENTICATION_BACKENDS</span> <span class=o>=</span> <span class=p>(</span>
    <span class=c1># This is the necessary additional backend</span>
    <span class=s2>"authlib.backends.PermissionsBackend"</span><span class=p>,</span>
    <span class=c1># Maybe you want to use authlib's email authentication ...</span>
    <span class=s2>"authlib.backends.EmailBackend"</span><span class=p>,</span>
    <span class=c1># ... or the standard username & password combination:</span>
    <span class=s2>"django.contrib.auth.backends.ModelBackend"</span><span class=p>,</span>
<span class=p>)</span>
</code></pre></div><p>You have to extend your user model (you have to use <a href=https://docs.djangoproject.com/en/4.2/topics/auth/customizing/#specifying-custom-user-model>a custom user model</a> if you’re not using django-authlib’s <code>little_user.User</code>):<div class=chl><pre><span></span><code><span class=kn>from</span> <span class=nn>authlib.roles</span> <span class=kn>import</span> <span class=n>RoleField</span>

<span class=k>class</span> <span class=nc>User</span><span class=p>(</span><span class=n>AbstractUser</span><span class=p>):</span>
    <span class=c1># ...</span>
    <span class=n>role</span> <span class=o>=</span> <span class=n>RoleField</span><span class=p>()</span>
</code></pre></div><p>And that’s basically it.<p>Of course the globbing is flexible, you could also allow users to view all objects:<div class=chl><pre><span></span><code><span class=n>partial</span><span class=p>(</span><span class=n>allow_deny_globs</span><span class=p>,</span> <span class=n>allow</span><span class=o>=</span><span class=p>{</span><span class=s2>"*.view_*"</span><span class=p>})</span>
</code></pre></div><p>Or you could block users from deleting anything:<div class=chl><pre><span></span><code><span class=n>partial</span><span class=p>(</span><span class=n>allow_deny_globs</span><span class=p>,</span> <span class=n>deny</span><span class=o>=</span><span class=p>{</span><span class=s2>"*.delete_*"</span><span class=p>})</span>
</code></pre></div><p>And as mentioned above, you can also combine <code>allow</code> and <code>deny</code> (<code>deny</code> wins over <code>allow</code>) or even provide your own callables. If you provide your own callable it must accept <code>user</code>, <code>perm</code> and <code>obj</code> (which may be <code>None</code>) as keyword arguments. Implementing such a callable is probably less work than implementing an authentication backend yourself; I had to do more work than initially expected because only implementing <code>.has_perm</code> isn’t sufficient if you want to see any apps and models in the admin index page. The current <code>allow_deny_globs</code> implementation is nice and short:<div class=chl><pre><span></span><code><span class=k>def</span> <span class=nf>allow_deny_globs</span><span class=p>(</span><span class=n>user</span><span class=p>,</span> <span class=n>perm</span><span class=p>,</span> <span class=n>obj</span><span class=p>,</span> <span class=n>allow</span><span class=o>=</span><span class=p>(),</span> <span class=n>deny</span><span class=o>=</span><span class=p>()):</span>
    <span class=k>for</span> <span class=n>rule</span> <span class=ow>in</span> <span class=n>deny</span><span class=p>:</span>
        <span class=k>if</span> <span class=n>fnmatch</span><span class=p>(</span><span class=n>perm</span><span class=p>,</span> <span class=n>rule</span><span class=p>):</span>
            <span class=k>raise</span> <span class=n>PermissionDenied</span>
    <span class=k>return</span> <span class=nb>any</span><span class=p>(</span><span class=n>fnmatch</span><span class=p>(</span><span class=n>perm</span><span class=p>,</span> <span class=n>rule</span><span class=p>)</span> <span class=k>for</span> <span class=n>rule</span> <span class=ow>in</span> <span class=n>allow</span><span class=p>)</span>
</code></pre></div></div></div></main><footer><div class=wrappy><p><small> I like feedback! <a href="mailto:mk@406.ch?subject=Keep content managers' admin access up-to-date with role-based permissions">Send me an email.</a> <br> <a rel="noopener noreferrer"href=https://ko-fi.com/matthiask target=_blank>☕ Buy me a coffee?</a> <br> Published on 2023-09-20 in <a href=/writing/category-django/>Django</a>, <a href=/writing/category-programming/>Programming</a>, <a href=/writing/category-feincms/>feincms</a> </small></p><script async crossorigin issue-term=pathname repo=matthiask/406-comments src=https://utteranc.es/client.js theme=github-light></script></div></footer>