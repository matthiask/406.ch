<!doctypehtml><html lang=en><meta charset=utf-8><meta content=width=device-width,initial-scale=1.0 name=viewport><title>django-tree-queries - Matthias Kestenholz</title><link href=/styles.d2047758144a.css rel=stylesheet><link title="Blog feed"href=/writing/atom.xml rel=alternate type=application/atom+xml><body><header><div class=wrappy><a class=title href=/>Hi, I'm Matthias</a><p class=subtitle>I am a founding partner of <a href=https://feinheit.ch>Feinheit AG</a> and <a href=https://diebruchpiloten.com>Die Bruchpiloten AG</a>. Find me on <a href=https://github.com/matthiask/>GitHub</a>, <a href=https://hachyderm.io/@matthiask rel=me>Mastodon</a>, <a rel="noopener noreferrer"title="if you must"href=https://www.linkedin.com/in/matthiaskestenholz target=_blank>LinkedIn</a> or by <a href=mailto:mk@406.ch>email</a>.<nav><a href=/writing/category-climate/>Climate</a><a href=/writing/category-django/>Django</a><a href=/writing/category-feincms/>feincms</a><a href=/writing/category-politik/>Politik</a><a href=/writing/category-programming/>Programming</a><a href=/writing/category-python/>Python</a><a href=/writing/category-weeknotes/>Weeknotes</a></nav></div></header><main><div class=wrappy><div class=text><small>2020-09-15 </small><h1 id=django-tree-queries><a class=toclink href=#django-tree-queries>django-tree-queries</a></h1><p>The reason for this blog post is the recent release of <a href=https://django-tree-queries.readthedocs.io/>django-tree-queries 0.4</a>. django-tree-queries allows using an SQL database to retrieve tree nodes in <a href=https://en.wikipedia.org/wiki/Depth-first_search>depth-first search (DFS)</a> order.<h2 id=other-libraries><a class=toclink href=#other-libraries>Other libraries</a></h2><p>Many Django libraries exist already for managing and retrieving tree-shaped data. A list of them follows along with reasons why none of them are being used in <a href=https://feincms3.readthedocs.io/>feincms3</a>.<h3 id=django-mptt><a class=toclink href=#django-mptt><a href=https://django-mptt.readthedocs.io/>django-mptt</a></a></h3><p>I still am a heavy user of django-mptt. FeinCMS 1.x uses it and we therefore use django-mptt as well for many sites which are actively maintained. I also am a co-maintainer of django-mptt so the following critique should be understood with this fact in mind.<p>django-mptt uses the <a href=https://en.wikipedia.org/wiki/Nested_set_model>nested set model</a> with an additional <code>level</code> and <code>tree_id</code> field; the latter partitions nodes into individual, unconnected trees. This is a useful performance optimization. In principle, the nested set model doesn’t even require a parent foreign key for nodes; however, django-mptt always adds this field as well.<p>django-mptt is very dependent on having up-to-date values of the <code>left</code>, <code>right</code> and <code>parent_id</code> values. Fetching ancestors or descendants does not work when those values are outdated. Calling <code>.save()</code> with outdated values <em>absolutely will</em> cause corrupted trees – that is, the MPTT attributes get out of sync. A band-aid fix may be to call <code>.refresh_from_db()</code> before each write; but even then I suspect there is a potential for corruption with concurrent writes which are probably only completely avoidable by using a database isolation level of <code>SERIALIZABLE</code>.<p>We had recurring problems with django-mptt even on medium sites without many editors so these problems aren’t just theoretical<sup id=fnref:djcms><a class=footnote-ref href=#fn:djcms>1</a></sup>.<h3 id=django-treebeard><a class=toclink href=#django-treebeard><a href=https://django-treebeard.readthedocs.io/>django-treebeard</a></a></h3><p>django-treebeard offers three implementations: Nested sets, materialized paths and adjacency lists.<p>I didn’t really want to use more nested sets. The materialized path implementation would probably have been worth a try. The adjacency list implementation does not use recursive CTEs and therefore has to recursively execute one query per parent. This is obviously inefficient and therefore not viable.<p>I’m not 100% sure anymore but I think I had some doubts regarding the maintainability of django-treebeard. I do like to help out generally, but treebeard still seems to suffer from scope creep a bit.<h3 id=ltree-closure-trees-oh-my><a class=toclink href=#ltree-closure-trees-oh-my>ltree, closure trees, oh my…</a></h3><p>I also looked at libraries using the <a href=https://www.postgresql.org/docs/current/ltree.html>ltree PostgreSQL extension</a>, and at closure trees and so on. Those solutions didn’t seem obviously better to me, at the time.<h3 id=django-cte-trees-django-cte-forest><a class=toclink href=#django-cte-trees-django-cte-forest><a href=https://django-cte-trees.readthedocs.io/>django-cte-trees</a> / <a href=https://django-cte-forest.readthedocs.io/>django-cte-forest</a></a></h3><p>Researching alternative solutions lead me to the <a href=https://django-cte-trees.readthedocs.io/>django-cte-trees</a> project which uses the adjacency list model and therefore avoids redundant data in the database – a thing which elegantly avoids even the possibility of data getting out of sync. Databases are able to build the tree structure with hundreds of nodes themselves and still execute SQL queries within milliseconds.<p>django-cte-forest was my attempt to modernize the codebase of the unmaintained project. This worked well enough. However, for some use cases I really wanted to avoid the common table expression. A better way to achieve this would have been an opt-in instead of an opt-out API for the CTE part. This proofed hard to implement. Also, django-cte-trees supported many many features that I didn’t even begin to use.<h2 id=the-constraints-of-django-tree-queries><a class=toclink href=#the-constraints-of-django-tree-queries>The constraints of django-tree-queries</a></h2><p>This research lead me to write my own solution. The goals were as follows<sup id=fnref:goals><a class=footnote-ref href=#fn:goals>2</a></sup>:<ul><li>Depth-first search only.<li>No customizations of deletions etc, let Django’s <code>on_delete</code> mechanism handle everything.<li>It’s fine if primary keys must be integers (and not UUIDs etc.)<li>As little customization as possible.<li>No redundant data in the database. A nullable parent foreign key and optionally a position field to give ordering to siblings.<li>PostgreSQL-only is fine.<li>Tree querying shouldn’t be active by default.</ul><p>Recursive common table expressions (CTE) might just be fast enough. As long as you guarantee that the database only contains trees things will never get out of sync or break. The only data corruption which is possible is when a node contains itself in its ancestry. Right now, django-tree-queries doesn’t handle this case because it may come with an (additional) performance penalty and because I think model validation is sufficient for avoiding these types of accidents.<h2 id=the-value-of-small-api-surfaces><a class=toclink href=#the-value-of-small-api-surfaces>The value of small API surfaces</a></h2><p>The initial version of django-tree-queries only supported PostgreSQL, but because of its small API surface it didn’t take a lot of work to add support for other databases. In the end only two changes were necessary:<ul><li>MySQL/MariaDB and sqlite3 do not have a native array type. I therefore decided on concatenating padded strings in the database and splitting the string back into its parts in Python again.<li>I had to write slightly different SQL for each database.</ul><p>This worked out quite well and immediately made <a href=https://feincms3.readthedocs.io/>feincms3</a> compatible with a broader range of databases.<h2 id=the-state-of-things-now><a class=toclink href=#the-state-of-things-now>The state of things now</a></h2><p><a href=https://dwheeler.com/sloccount/>SLOCCount</a> counts 280 lines of code (only the <code>tree_queries</code> folder containing the library itself, without tests or <code>setup.py</code> files) for a library supporting Django 1.8 or better, Python 2.7 or better, and recursive CTEs on PostgreSQL, sqlite3, MariaDB and MySQL.<p>The first few months of development from summer to the fall of 2018 almost no changes were necessary to the core implementation. The code stayed basically unchanged since before the release of Django 2.2 LTS until last week<sup id=fnref:change><a class=footnote-ref href=#fn:change>3</a></sup>, following my aim of writing <a href=https://406.ch/writing/low-maintenance-software/>low maintenance software</a>.<div class=footnote><hr><ol><li id=fn:djcms><p><a href=https://www.django-cms.org/>django CMS</a> was a heavy user of django-mptt until 2015, when they switched to django-treebeard because of the problems mentioned. <a title="Jump back to footnote 1 in the text"class=footnote-backref href=#fnref:djcms>↩</a></p><li id=fn:goals><p>That’s probably colored by hindsight and wasn’t completely worked out at the time. <a title="Jump back to footnote 2 in the text"class=footnote-backref href=#fnref:goals>↩</a></p><li id=fn:change><p>The only recent change improves performance on PostgreSQL by going back to using integers directly instead of casting them to <code>::text</code> if it isn’t necessary. <a title="Jump back to footnote 3 in the text"class=footnote-backref href=#fnref:change>↩</a></p></ol></div></div></div></main><footer><div class=wrappy><p><small> I like feedback! <a href=mailto:mk@406.ch?subject=django-tree-queries>Send me an email.</a> <br> <a rel="noopener noreferrer"href=https://ko-fi.com/matthiask target=_blank>☕ Buy me a coffee?</a> <br> Published on 2020-09-15 in <a href=/writing/category-django/>Django</a>, <a href=/writing/category-programming/>Programming</a>, <a href=/writing/category-feincms/>feincms</a> </small></p><script async crossorigin issue-term=pathname repo=matthiask/406-comments src=https://utteranc.es/client.js theme=github-light></script></div></footer>